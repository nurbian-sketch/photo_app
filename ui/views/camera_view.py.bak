import os
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QSplitter, QSizePolicy, QDialog
)
from PyQt6.QtCore import Qt, QSettings, pyqtSignal, QTimer
from PyQt6.QtGui import QPixmap, QTransform

from core.gphoto_interface import GPhotoInterface

from ui.views.camera_components.exposure_controls import ExposureControls
from ui.views.camera_components.image_controls import ImageControls
from ui.views.camera_components.autofocus_controls import AutofocusControls



def _read_exif(path: str) -> dict:
    """
    Czyta podstawowe dane EXIF z pliku.
    Zwraca dict: shutter, aperture, iso, focal, date, dims, size, camera.
    """
    result = {'shutter':'','aperture':'','iso':'','focal':'','date':'','dims':'','size':'','camera':''}
    try:
        from PIL import Image
        from PIL.ExifTags import TAGS

        img = Image.open(path)
        w, h = img.size
        result['dims'] = f"{w}\u00d7{h}"
        size_bytes = os.path.getsize(path)
        result['size'] = f"{size_bytes/(1024*1024):.1f} MB"

        exif_raw = img._getexif()
        if not exif_raw:
            return result
        exif = {TAGS.get(k, k): v for k, v in exif_raw.items()}

        exp = exif.get("ExposureTime")
        if exp:
            n = exp.numerator if hasattr(exp,"numerator") else exp[0]
            d = exp.denominator if hasattr(exp,"denominator") else exp[1]
            result["shutter"] = f"1/{int(round(d/n))}s" if n and d/n>=1 else (f"{n/d:.1f}s" if n else "—")

        fn = exif.get("FNumber")
        if fn:
            n = fn.numerator if hasattr(fn,"numerator") else fn[0]
            d = fn.denominator if hasattr(fn,"denominator") else fn[1]
            result["aperture"] = f"f/{n/d:.1f}"

        iso = exif.get("ISOSpeedRatings")
        if iso:
            result["iso"] = f"ISO\u00a0{iso}"

        fl = exif.get("FocalLength")
        if fl:
            n = fl.numerator if hasattr(fl,"numerator") else fl[0]
            d = fl.denominator if hasattr(fl,"denominator") else fl[1]
            result["focal"] = f"{int(round(n/d))}mm"

        date = exif.get("DateTimeOriginal") or exif.get("DateTime","")
        if date:
            date = str(date).replace(":","\u2011",2)
            result["date"] = date[:16]

        make  = str(exif.get("Make","")).strip()
        model = str(exif.get("Model","")).strip()
        if model:
            result["camera"] = model if model.startswith(make) else (f"{make} {model}" if make else model)
    except Exception:
        pass
    return result

# ─────────────────────────────── Popup podglądu zdjęcia

class CapturePreviewDialog(QDialog):
    """Okno podglądu przechwyconego zdjęcia z kontrolkami zoom/pan/rotate."""

    def __init__(self, image_path, parent=None):
        super().__init__(parent)
        self.setWindowTitle(os.path.basename(image_path))
        self.setMinimumSize(640, 480)
        self.resize(1024, 768)
        self.setWindowFlags(
            Qt.WindowType.Window
            | Qt.WindowType.WindowCloseButtonHint
            | Qt.WindowType.WindowMaximizeButtonHint
        )

        # Ciemny motyw jak main window (#3d3d3d)
        self.setStyleSheet("""
            QDialog { background-color: #3d3d3d; }
            QPushButton { 
                background-color: #4a4a4a; 
                color: #ccc; 
                border: 1px solid #555;
                border-radius: 3px;
            }
            QPushButton:hover { background-color: #5a5a5a; }
            QPushButton:pressed { background-color: #3a3a3a; }
            QLabel { color: #ccc; }
        """)

        self._image_path = image_path
        self._original_pixmap = QPixmap(image_path)
        self._pixmap = self._original_pixmap  # Po rotacji
        self._rotation = 0  # 0, 90, 180, 270
        self._zoom = 1.0
        self._pan_offset = [0, 0]
        self._drag_start = None
        self._saved_geometry = None

        self._init_ui()

    def _init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Image label - tło takie samo jak okno
        self._label = QLabel()
        self._label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self._label.setStyleSheet("background: #3d3d3d;")
        self._label.setSizePolicy(
            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding
        )
        self._label.setMouseTracking(True)
        layout.addWidget(self._label)

        # Control bar - ten sam kolor co tło
        control_bar = QWidget()
        control_bar.setStyleSheet("background: #3d3d3d;")
        control_layout = QHBoxLayout(control_bar)
        control_layout.setContentsMargins(10, 5, 10, 5)
        control_layout.setSpacing(8)

        # Rotation controls
        btn_rotate_left = QPushButton("↶")
        btn_rotate_left.setFixedSize(32, 32)
        btn_rotate_left.setToolTip("Rotate left 90°")
        btn_rotate_left.setStyleSheet("font-size: 16px;")
        btn_rotate_left.clicked.connect(self._rotate_left)
        control_layout.addWidget(btn_rotate_left)

        btn_rotate_right = QPushButton("↷")
        btn_rotate_right.setFixedSize(32, 32)
        btn_rotate_right.setToolTip("Rotate right 90°")
        btn_rotate_right.setStyleSheet("font-size: 16px;")
        btn_rotate_right.clicked.connect(self._rotate_right)
        control_layout.addWidget(btn_rotate_right)

        # Separator
        sep = QLabel("|")
        sep.setStyleSheet("color: #555;")
        control_layout.addWidget(sep)

        # Zoom controls
        btn_zoom_out = QPushButton("−")
        btn_zoom_out.setFixedSize(32, 32)
        btn_zoom_out.setStyleSheet("font-size: 18px; font-weight: bold;")
        btn_zoom_out.clicked.connect(self._zoom_out)
        control_layout.addWidget(btn_zoom_out)

        self._zoom_label = QLabel("100%")
        self._zoom_label.setFixedWidth(50)
        self._zoom_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self._zoom_label.setStyleSheet("color: #888;")
        control_layout.addWidget(self._zoom_label)

        btn_zoom_in = QPushButton("+")
        btn_zoom_in.setFixedSize(32, 32)
        btn_zoom_in.setStyleSheet("font-size: 18px; font-weight: bold;")
        btn_zoom_in.clicked.connect(self._zoom_in)
        control_layout.addWidget(btn_zoom_in)

        btn_fit = QPushButton("Fit")
        btn_fit.setFixedSize(50, 32)
        btn_fit.clicked.connect(self._zoom_fit)
        control_layout.addWidget(btn_fit)

        btn_100 = QPushButton("1:1")
        btn_100.setFixedSize(50, 32)
        btn_100.clicked.connect(self._zoom_100)
        control_layout.addWidget(btn_100)

        # Spacer
        control_layout.addStretch()

        # File path
        path_label = QLabel(self._image_path)
        path_label.setStyleSheet("color: #555; font-size: 11px;")
        control_layout.addWidget(path_label)

        control_layout.addStretch()

        # Close button
        btn_close = QPushButton("Close")
        btn_close.setFixedSize(80, 32)
        btn_close.clicked.connect(self.close)
        control_layout.addWidget(btn_close)


        # EXIF bar — kompaktowy pasek z danymi zdjecia
        exif = _read_exif(image_path)
        exif_parts = []
        if exif['camera']:  exif_parts.append(exif['camera'])
        if exif['dims']:    exif_parts.append(exif['dims'])
        if exif['size']:    exif_parts.append(exif['size'])
        if exif['shutter']: exif_parts.append(exif['shutter'])
        if exif['aperture']: exif_parts.append(exif['aperture'])
        if exif['iso']:     exif_parts.append(exif['iso'])
        if exif['focal']:   exif_parts.append(exif['focal'])
        if exif['date']:    exif_parts.append(exif['date'])

        exif_text = "   •   ".join(exif_parts) if exif_parts else "No EXIF data"
        exif_bar = QLabel(exif_text)
        exif_bar.setStyleSheet(
            "background: #2a2a2a; color: #999; font-size: 11px; padding: 3px 10px;"
        )
        exif_bar.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(exif_bar)

        layout.addWidget(control_bar)

    def _rotate_left(self):
        """Obrót o -90°."""
        self._rotation = (self._rotation - 90) % 360
        self._apply_rotation()

    def _rotate_right(self):
        """Obrót o +90°."""
        self._rotation = (self._rotation + 90) % 360
        self._apply_rotation()

    def _apply_rotation(self):
        """Aplikuje rotację do pixmapy."""
        from PyQt6.QtGui import QTransform
        transform = QTransform().rotate(self._rotation)
        self._pixmap = self._original_pixmap.transformed(
            transform, Qt.TransformationMode.SmoothTransformation
        )
        self._pan_offset = [0, 0]
        self._zoom_fit()

    def keyPressEvent(self, event):
        """Obsługa F11 fullscreen i Escape."""
        if event.key() == Qt.Key.Key_F11:
            self._toggle_fullscreen()
        elif event.key() == Qt.Key.Key_Escape:
            if self.isFullScreen():
                self._toggle_fullscreen()
            else:
                self.close()
        elif event.key() == Qt.Key.Key_Left:
            self._rotate_left()
        elif event.key() == Qt.Key.Key_Right:
            self._rotate_right()
        else:
            super().keyPressEvent(event)

    def _toggle_fullscreen(self):
        """Przełącza tryb pełnoekranowy."""
        if self.isFullScreen():
            self.showNormal()
            if self._saved_geometry:
                self.setGeometry(self._saved_geometry)
        else:
            self._saved_geometry = self.geometry()
            self.showFullScreen()

    def showEvent(self, event):
        super().showEvent(event)
        QTimer.singleShot(50, self._zoom_fit)

    def _update_preview(self):
        if self._pixmap.isNull():
            self._label.setText(f"Cannot load image:\n{self._image_path}")
            return

        # Oblicz rozmiar obrazu po zoom
        img_w = int(self._pixmap.width() * self._zoom)
        img_h = int(self._pixmap.height() * self._zoom)

        if img_w < 1 or img_h < 1:
            return

        scaled = self._pixmap.scaled(
            img_w, img_h,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )

        # Jeśli obraz mniejszy niż label — wycentruj
        label_size = self._label.size()
        if scaled.width() <= label_size.width() and scaled.height() <= label_size.height():
            self._pan_offset = [0, 0]
            self._label.setPixmap(scaled)
        else:
            # Przytnij do widocznego obszaru z uwzględnieniem pan
            visible_w = min(scaled.width(), label_size.width())
            visible_h = min(scaled.height(), label_size.height())

            # Ogranicz pan do granic obrazu
            max_pan_x = max(0, scaled.width() - label_size.width())
            max_pan_y = max(0, scaled.height() - label_size.height())
            self._pan_offset[0] = max(0, min(self._pan_offset[0], max_pan_x))
            self._pan_offset[1] = max(0, min(self._pan_offset[1], max_pan_y))

            cropped = scaled.copy(
                int(self._pan_offset[0]), int(self._pan_offset[1]),
                visible_w, visible_h
            )
            self._label.setPixmap(cropped)

        self._zoom_label.setText(f"{int(self._zoom * 100)}%")

    def _zoom_in(self):
        self._zoom = min(self._zoom * 1.25, 10.0)
        self._update_preview()

    def _zoom_out(self):
        self._zoom = max(self._zoom / 1.25, 0.1)
        self._update_preview()

    def _zoom_fit(self):
        if self._pixmap.isNull():
            return
        label_size = self._label.size()
        if label_size.width() < 10 or label_size.height() < 10:
            QTimer.singleShot(100, self._zoom_fit)
            return
        scale_w = label_size.width() / self._pixmap.width()
        scale_h = label_size.height() / self._pixmap.height()
        self._zoom = min(scale_w, scale_h, 1.0)  # Nie powiększaj ponad 100%
        self._pan_offset = [0, 0]
        self._update_preview()

    def _zoom_100(self):
        self._zoom = 1.0
        self._pan_offset = [0, 0]
        self._update_preview()

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if self.isVisible():
            self._update_preview()

    def wheelEvent(self, event):
        """Zoom kółkiem myszy."""
        delta = event.angleDelta().y()
        if delta > 0:
            self._zoom_in()
        elif delta < 0:
            self._zoom_out()

    def mousePressEvent(self, event):
        """Rozpocznij pan."""
        if event.button() == Qt.MouseButton.LeftButton:
            self._drag_start = event.pos()

    def mouseMoveEvent(self, event):
        """Pan podczas przeciągania."""
        if self._drag_start is not None:
            delta = event.pos() - self._drag_start
            self._pan_offset[0] -= delta.x()
            self._pan_offset[1] -= delta.y()
            self._drag_start = event.pos()
            self._update_preview()

    def mouseReleaseEvent(self, event):
        """Zakończ pan."""
        if event.button() == Qt.MouseButton.LeftButton:
            self._drag_start = None


# ─────────────────────────────── Widok kamery

class CameraView(QWidget):

    # Sygnał żądania ponownego połączenia z aparatem
    reconnect_requested = pyqtSignal()

    # Klucz QSettings — taki sam jak w PreferencesDialog
    KEY_SESSION_DIR = "session/directory"
    
    # Domyślny katalog na sesje
    DEFAULT_SESSION_DIR = os.path.expanduser("~/Obrazy/sessions")

    def __init__(self, camera_service=None):
        super().__init__()
        self.cs = camera_service
        self.lv_thread = None
        self._camera_ready = False
        self._needs_reconnect = False  # Flaga: było zerwane połączenie
        self._settings = QSettings("Grzeza", "SessionsAssistant")
        self._capture_dir = self._get_capture_directory()
        self._preview_dialogs = []  # Referencje do otwartych podglądów
        self._init_ui()

    def _get_capture_directory(self) -> str:
        """Pobiera katalog sesji z QSettings z migracją starej ścieżki."""
        saved = self._settings.value(self.KEY_SESSION_DIR, "")
        
        # Migracja: stara domyślna ścieżka → nowa
        if not saved or "Pictures/sessions" in saved or "Pictures/SessionsAssistant" in saved:
            self._settings.setValue(self.KEY_SESSION_DIR, self.DEFAULT_SESSION_DIR)
            return self.DEFAULT_SESSION_DIR
        
        return saved

    def update_capture_directory(self):
        """Odświeża katalog sesji z QSettings (po zmianie w Preferences)."""
        self._capture_dir = self._get_capture_directory()

    def _init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 15, 15, 15)

        # --- SPLITTER ---
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        self.main_splitter.setHandleWidth(12)

        # ---- LEFT: Control Panel (2 columns) ----
        control_panel = QWidget()
        control_panel.setMinimumWidth(760)
        control_layout = QHBoxLayout(control_panel)
        control_layout.setContentsMargins(0, 0, 0, 0)
        control_layout.setSpacing(30)

        # Column 1: Exposure + buttons
        col1 = QWidget()
        col1.setMinimumWidth(450)
        col1_layout = QVBoxLayout(col1)
        col1_layout.setContentsMargins(0, 0, 0, 0)

        self.exposure_ctrl = ExposureControls()
        self.exposure_ctrl.setEnabled(False)
        col1_layout.addWidget(self.exposure_ctrl, 3)
        col1_layout.addSpacing(20)
        col1_layout.addStretch(1)

        row1 = QHBoxLayout()
        self.btn_save = QPushButton("Save")
        self.btn_load = QPushButton("Load")
        row1.addWidget(self.btn_save)
        row1.addWidget(self.btn_load)
        row1.addStretch()
        col1_layout.addLayout(row1)

        # Column 2: Image + Focus + buttons
        col2 = QWidget()
        col2.setMinimumWidth(280)
        col2_layout = QVBoxLayout(col2)
        col2_layout.setContentsMargins(0, 0, 0, 0)

        self.image_ctrl = ImageControls()
        self.image_ctrl.setEnabled(False)
        self.focus_ctrl = AutofocusControls()
        self.focus_ctrl.setEnabled(False)
        col2_layout.addWidget(self.image_ctrl, 2)
        col2_layout.addSpacing(8)
        col2_layout.addWidget(self.focus_ctrl, 1)
        col2_layout.addSpacing(20)
        col2_layout.addStretch(1)

        row2 = QHBoxLayout()
        self.btn_update = QPushButton("UPDATE")
        self.btn_cancel = QPushButton("CANCEL")
        self.btn_update.setStyleSheet("font-weight: bold; color: #2e7d32;")
        row2.addWidget(self.btn_update)
        row2.addWidget(self.btn_cancel)
        row2.addStretch()
        col2_layout.addLayout(row2)

        control_layout.addWidget(col1, 5)
        control_layout.addWidget(col2, 3)

        # ---- RIGHT: Live View ----
        preview_panel = QWidget()
        preview_panel.setMinimumWidth(400)
        preview_layout = QVBoxLayout(preview_panel)
        preview_layout.setContentsMargins(0, 0, 0, 0)

        self.lv_screen = QLabel("LIVE VIEW OFF")
        self.lv_screen.setStyleSheet(
            "background: #3d3d3d; border: 2px solid #555; color: white;"
        )
        self.lv_screen.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lv_screen.setSizePolicy(
            QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Ignored
        )
        preview_layout.addWidget(self.lv_screen)

        row3 = QHBoxLayout()
        row3.setContentsMargins(0, 5, 0, 0)
        self.btn_lv = QPushButton("START LIVE VIEW")
        self.btn_cap = QPushButton("CAPTURE PHOTO")
        self.btn_lv.setFixedSize(200, 40)
        self.btn_cap.setFixedSize(180, 40)
        self.btn_cap.setStyleSheet("font-weight: bold;")
        row3.addStretch()
        row3.addWidget(self.btn_lv)
        row3.addWidget(self.btn_cap)
        row3.addStretch()
        preview_layout.addLayout(row3)

        # Splitter setup
        self.main_splitter.addWidget(control_panel)
        self.main_splitter.addWidget(preview_panel)
        self.main_splitter.setCollapsible(0, False)
        self.main_splitter.setCollapsible(1, False)
        self.main_splitter.setStretchFactor(0, 4)
        self.main_splitter.setStretchFactor(1, 6)
        main_layout.addWidget(self.main_splitter)

        # --- SIGNALS ---
        self.btn_update.clicked.connect(self._on_update_clicked)
        self.btn_lv.clicked.connect(self._toggle_liveview)
        self.btn_cap.clicked.connect(self._on_capture_clicked)

        # Wszystkie przyciski wyłączone do momentu wykrycia aparatu
        self._set_buttons_enabled(False)

    # ─────────────────────────────── FRAME UPDATE

    def _update_frame(self, data, is_blinking):
        pixmap = QPixmap()
        if pixmap.loadFromData(data):
            scaled = pixmap.scaled(
                self.lv_screen.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.FastTransformation
            )
            self.lv_screen.setPixmap(scaled)
            if is_blinking:
                self.lv_screen.setStyleSheet(
                    "background: #3d3d3d; border: 2px solid #ff8a65;"
                )
            else:
                self.lv_screen.setStyleSheet(
                    "background: #3d3d3d; border: 2px solid #555;"
                )

    # --- CAMERA READY STATE ---

    def set_camera_ready(self, ready):
        """Ustawia stan gotowości aparatu — włącza/wyłącza przyciski."""
        self._camera_ready = ready
        
        # Aktualizuj tekst przycisku LV w zależności od stanu
        if not ready:
            # Brak aparatu — przycisk służy do połączenia
            self.btn_lv.setText("CONNECT CAMERA")
            self.btn_lv.setStyleSheet("")
            self.btn_lv.setEnabled(True)
        elif not (self.lv_thread and self.lv_thread.isRunning()):
            # Aparat gotowy, LV nieaktywne
            self.btn_lv.setText("START LIVE VIEW")
            self.btn_lv.setStyleSheet("")
            self.btn_lv.setEnabled(True)
        
        # Przyciski aktywne tylko gdy aparat podłączony i LV nieaktywne
        if not (self.lv_thread and self.lv_thread.isRunning()):
            self._set_buttons_enabled(ready)

    def _set_buttons_enabled(self, enabled):
        """Włącza/wyłącza przyciski zależne od aparatu.
        Uwaga: btn_lv jest zawsze aktywny (CONNECT/START/STOP/RECONNECT)."""
        # btn_lv NIE jest tutaj — zarządzany osobno w set_camera_ready()
        self.btn_cap.setEnabled(enabled and self.lv_thread is not None
                                and self.lv_thread.isRunning())
        self.btn_save.setEnabled(enabled)
        self.btn_update.setEnabled(enabled)

    # --- LIVE VIEW & GPHOTO LOGIC ---

    def _toggle_liveview(self):
        """Przełącza stan wątku interfejsu gphoto.
        RECONNECT = probe + auto-start LV."""
        if self.lv_thread and self.lv_thread.isRunning():
            # LV aktywne → zatrzymaj
            self._stop_lv()
        elif self._needs_reconnect:
            # Zerwane połączenie → probe i jeśli OK to od razu start LV
            self._needs_reconnect = False
            self._try_reconnect()
        elif not self._camera_ready:
            # Brak aparatu → tylko probe (bez auto-start)
            self.reconnect_requested.emit()
        else:
            # Aparat gotowy → uruchom LV
            self._start_lv()

    def _try_reconnect(self):
        """Próbuje reconnect: probe + auto-start LV."""
        # Emituj sygnał żeby main_window zrobił probe
        self.reconnect_requested.emit()
        # Po probe set_camera_ready() zaktualizuje _camera_ready
        # Jeśli aparat dostępny, auto-start LV
        QTimer.singleShot(500, self._auto_start_after_reconnect)

    def _auto_start_after_reconnect(self):
        """Auto-start LV po udanym reconnect."""
        if self._camera_ready and not (self.lv_thread and self.lv_thread.isRunning()):
            self._start_lv()

    def _start_lv(self):
        """Inicjalizuje i uruchamia interfejs gphoto."""
        self.btn_lv.setEnabled(False)  # Blokada wielokrotnego kliknięcia

        self.lv_thread = GPhotoInterface()

        self.exposure_ctrl.gphoto = self.lv_thread
        self.image_ctrl.gphoto = self.lv_thread
        self.focus_ctrl.gphoto = self.lv_thread

        self.lv_thread.settings_loaded.connect(self.exposure_ctrl.sync_with_camera)
        self.lv_thread.settings_loaded.connect(self.image_ctrl.sync_with_camera)
        self.lv_thread.settings_loaded.connect(self.focus_ctrl.sync_with_camera)
        self.lv_thread.frame_received.connect(self._update_frame)
        self.lv_thread.error_occurred.connect(self._on_lv_error)
        self.lv_thread.image_captured.connect(self._on_image_captured)
        self.lv_thread.capture_failed.connect(self._on_capture_failed)

        self.lv_thread.start()

        self.exposure_ctrl.setEnabled(True)
        self.image_ctrl.setEnabled(True)
        self.focus_ctrl.setEnabled(True)
        self.btn_lv.setEnabled(True)  # Teraz działa jako STOP
        self.btn_cap.setEnabled(True)  # Capture dostępny podczas LV
        self.btn_lv.setText("STOP LIVE VIEW")
        self.btn_lv.setStyleSheet(
            "background-color: #c62828; color: white; font-weight: bold;"
        )

    def _stop_lv(self):
        """Zatrzymuje wątek i czyści widok."""
        if self.lv_thread:
            self.lv_thread.stop()
            self.exposure_ctrl.gphoto = None
            self.image_ctrl.gphoto = None
            self.focus_ctrl.gphoto = None

        self.exposure_ctrl.setEnabled(False)
        self.image_ctrl.setEnabled(False)
        self.focus_ctrl.setEnabled(False)
        self.lv_screen.clear()
        self.lv_screen.setText("LIVE VIEW OFF")
        self.lv_screen.setStyleSheet(
            "background: #3d3d3d; border: 2px solid #555; color: white;"
        )
        self.btn_lv.setText("START LIVE VIEW")
        self.btn_lv.setStyleSheet("")
        self.btn_cap.setEnabled(False)

    def _on_lv_error(self, error_msg):
        """Obsługa błędów live view."""
        if self.lv_thread:
            self.lv_thread.stop()
            self.exposure_ctrl.gphoto = None
            self.image_ctrl.gphoto = None
            self.focus_ctrl.gphoto = None
            self.lv_thread = None

        self.exposure_ctrl.setEnabled(False)
        self.image_ctrl.setEnabled(False)
        self.focus_ctrl.setEnabled(False)
        self._set_buttons_enabled(False)
        
        # Spokojny komunikat dla użytkownika
        self.lv_screen.setText("Connection lost.\nClick to reconnect.")
        self.lv_screen.setStyleSheet(
            "background: #3d3d3d; border: 2px solid #555; color: #888;"
        )
        
        # Przycisk RECONNECT — NIE zmieniamy _camera_ready
        # (to zrobi probe po kliknięciu)
        self._needs_reconnect = True
        self.btn_lv.setEnabled(True)
        self.btn_lv.setText("RECONNECT")
        self.btn_lv.setStyleSheet("")

    # --- CAPTURE ---

    def _on_capture_clicked(self):
        """Kolejkuje zdjęcie na wątku gphoto."""
        if self.lv_thread and self.lv_thread.isRunning():
            self.btn_cap.setEnabled(False)  # Blokada wielokrotnego kliknięcia
            self.btn_cap.setText("CAPTURING...")
            # Upewnij się że mamy aktualny katalog
            self.update_capture_directory()
            self.lv_thread.capture_photo(self._capture_dir)

    def _on_image_captured(self, file_path):
        """Callback: zdjęcie zapisane — otwórz podgląd."""
        print(f"Image captured: {file_path}")
        self.btn_cap.setEnabled(True)
        self.btn_cap.setText("CAPTURE PHOTO")

        dialog = CapturePreviewDialog(file_path, parent=None)
        dialog.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose)
        dialog.destroyed.connect(lambda: self._preview_dialogs.remove(dialog)
                                 if dialog in self._preview_dialogs else None)
        self._preview_dialogs.append(dialog)
        dialog.show()

    def _on_capture_failed(self, error_msg):
        """Obsługa błędu capture — NIE zabija sesji LV."""
        print(f"Capture failed: {error_msg}")
        # Tylko reset przycisku — LV samo się odzyska
        self.btn_cap.setEnabled(True)
        self.btn_cap.setText("CAPTURE PHOTO")

    # --- LEAVE / ENTER ---

    def on_leave(self):
        """Wywoływane przy opuszczeniu widoku Camera.
        Zamyka sesję PTP i resetuje UI do stanu początkowego."""
        if self.lv_thread and self.lv_thread.isRunning():
            self._stop_lv()
        # Reset UI niezależnie od stanu (np. po RECONNECT)
        self.lv_thread = None
        self._needs_reconnect = False  # Reset flagi przy opuszczeniu widoku
        self.exposure_ctrl.gphoto = None
        self.image_ctrl.gphoto = None
        self.focus_ctrl.gphoto = None
        self.exposure_ctrl.setEnabled(False)
        self.image_ctrl.setEnabled(False)
        self.focus_ctrl.setEnabled(False)
        self.lv_screen.clear()
        self.lv_screen.setText("LIVE VIEW OFF")
        self.lv_screen.setStyleSheet(
            "background: #3d3d3d; border: 2px solid #555; color: white;"
        )
        self.btn_lv.setText("START LIVE VIEW")
        self.btn_lv.setStyleSheet("")
        self.btn_cap.setEnabled(False)
        self._set_buttons_enabled(self._camera_ready)

    def close_all_previews(self):
        """Zamyka wszystkie otwarte okna podglądu zdjęć."""
        for dialog in list(self._preview_dialogs):
            try:
                dialog.close()
            except Exception:
                pass
        self._preview_dialogs.clear()

    def _on_update_clicked(self):
        """Zbiera ustawienia i wysyła (zachowano dla kompatybilności)."""
        settings = {}
        settings.update(self.exposure_ctrl.get_settings())
        settings.update(self.image_ctrl.get_settings())
        settings.update(self.focus_ctrl.get_settings())
        if self.cs:
            self.cs.apply_bulk_settings(settings)
